## C++ Primer 第九章 顺序容器
一个容器就是一个特定类型对象的集合。顺序容器，提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

```
vector          可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除，可能比较慢
deque           双端队列。支持快速随机访问。在头尾插入/删除速度都很快。
list            双向链表。只支持双向顺序访问。插入/删除速度快。
forward_list    单向链表。只支持单向顺序访问。插入/删除速度快。没有保存size大小。
array           固定大小数组。支持快速随机访问。不能添加或删除元素。
string          与vector相似的容器，专门用于保存字符串。
```
顺序容器几乎可以保存任意类型的元素。但如果没有构造函数，可能会导致错误。
```
//假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init);     //正确：提供了元素初始化器
vector<noDefault> v2(10, init);     //错误：必须提供一个元素初始化器
```

一些以前少用的操作：
```
a.swap(b)   //交换a和b的元素
swap(a,b)   //同a.swap(b)

c.cbegin(), c.cend()    //返回const_iterator，这是可以读取元素但不能修改元素的迭代器类型
c.rbegin(), c.rend()    //按逆序寻址元素的迭代器
```

### 迭代器
与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。例如，标准容器类型上的所有迭代器都允许我们访问容器中的元素，而所有迭代器都是通过解引用运算符来实现这个操作的。同时，所有迭代器都定义了递归运算符，从当前元素移动到下一个元素。

有一个例外不符合公共接口特点——forward_list迭代器不支持递减运算符(--)

迭代器的范围是:`[begin(), end())` 左闭右开的区间
我们可以这样子来处理一个元素的范围：
```
while(begin!= end){
    *begin = val;   //非空，可以获取元素
    ++begin;        //移动迭代器
}
```

### 删除操作
```
c.erase(p)      //删除迭代器所指定的元素，返回一个指向被删元素之后元素的迭代器。若p指向尾元素，则返回尾后迭代器(end)。
c.erase(b,e)    //删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删除元素之后元素的迭代器。若e是尾后迭代器，则函数返回尾后迭代器(end)。
```